<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { STLExporter } from "three/addons/exporters/STLExporter.js";
import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";

/* ==========================
   Safety + diagnostics
========================== */
const status = document.getElementById("status");
const log = (m) => status.textContent = m;

window.addEventListener("error", (e) => {
  console.error(e.error || e.message);
  const msg = e.error?.stack || e.message || String(e);
  log("❌ JS ERROR:\n" + msg);
});

window.addEventListener("unhandledrejection", (e) => {
  console.error(e.reason);
  const msg = e.reason?.stack || e.reason?.message || String(e.reason);
  log("❌ PROMISE ERROR:\n" + msg);
});

let BUSY = false;
function setBusy(on, msg){
  BUSY = on;
  document.getElementById("gen").disabled = on;
  document.getElementById("export").disabled = on;
  if (msg) log(msg);
}

/* ==========================
   Optional CSG (slots)
========================== */
let Brush, Evaluator, SUBTRACTION;
let CSG_OK = false;

async function loadCSG(){
  try{
    ({ Brush, Evaluator, SUBTRACTION } =
      await import("https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js"));
    CSG_OK = true;
  }catch(e){
    console.warn("CSG load failed:", e);
    CSG_OK = false;
  }
}
await loadCSG();

/* ==========================
   Scene setup
========================== */
const view = document.getElementById("view");
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0d12);

const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 5000);
camera.position.set(120, 90, 120);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
view.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff, 0.65));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(120, 200, 80);
scene.add(dir);

let gridHelper = new THREE.GridHelper(500, 20, 0x2a3558, 0x222a40);
gridHelper.position.y = -0.01;
scene.add(gridHelper);

const material = new THREE.MeshStandardMaterial({ metalness:0.05, roughness:0.8 });
let currentMesh = null;

const GRID = 25;
const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
const snapVal = (v, grid)=>Math.round(v/grid)*grid;

function safeMerge(list){
  const geos = list.filter(Boolean);
  const merged = mergeGeometries(geos, false);
  if (!merged) throw new Error("mergeGeometries returned null");
  return merged;
}

function csgSubtract(baseGeo, cutters){
  // If CSG isn’t available, just return base geometry (peg-only still works)
  if (!CSG_OK || !cutters.length) return baseGeo;

  const evalr = new Evaluator();
  let result = new Brush(baseGeo);
  for (const cutGeo of cutters){
    result = evalr.evaluate(result, new Brush(cutGeo), SUBTRACTION);
  }
  const g = result.geometry;
  g.computeVertexNormals();
  return g;
}

/* ==========================
   Connector helpers
========================== */
function connectorProfile(sizeMode, tol){
  let w = 12.0, h = 4.0;
  if (sizeMode === "tight"){ w = 11.5; h = 3.8; }
  if (sizeMode === "loose"){ w = 12.5; h = 4.2; }
  return {
    slotW: w + tol*2,
    slotH: h + tol*2,
    pegW: w - tol*1.5,
    pegH: h - tol*1.5
  };
}

function tileEdgeList(val){
  if (val === "all") return ["n","e","s","w"];
  if (val === "ns") return ["n","s"];
  if (val === "ew") return ["e","w"];
  return [val];
}
function wallFootList(val){
  if (val === "both") return ["left","right"];
  return [val];
}

/* ==========================
   Tile builder
========================== */
function buildTile({w,d,thickness,emboss,grid,conn}){
  const slab = new THREE.BoxGeometry(w, thickness, d);
  slab.translate(0, thickness/2, 0);

  const additions = [];
  const cutters = [];

  if (emboss === "on"){
    const step = grid;
    const lineW = 0.7, lineH = 0.6;
    for (let x = -w/2 + step; x < w/2; x += step){
      const g = new THREE.BoxGeometry(lineW, lineH, d*0.98);
      g.translate(x, thickness + lineH/2, 0);
      additions.push(g);
    }
    for (let z = -d/2 + step; z < d/2; z += step){
      const g = new THREE.BoxGeometry(w*0.98, lineH, lineW);
      g.translate(0, thickness + lineH/2, z);
      additions.push(g);
    }
  }

  if (conn.mode !== "none"){
    const prof = connectorProfile(conn.sizeMode, conn.tol);
    const edges = tileEdgeList(conn.tileEdges);
    const y = thickness*0.5;

    for (const e of edges){
      if ((conn.mode === "slots" || conn.mode === "both") && !CSG_OK){
        // If user requests slots but CSG isn't available, ignore slot cuts
      } else if (conn.mode === "slots" || conn.mode === "both"){
        const slot = new THREE.BoxGeometry(prof.slotW, prof.slotH, conn.slotDepth);
        if (e === "n") slot.translate(0, y, -d/2 + conn.inset + conn.slotDepth/2);
        if (e === "s") slot.translate(0, y,  d/2 - conn.inset - conn.slotDepth/2);
        if (e === "e"){ slot.rotateY(Math.PI/2); slot.translate( w/2 - conn.inset - conn.slotDepth/2, y, 0); }
        if (e === "w"){ slot.rotateY(Math.PI/2); slot.translate(-w/2 + conn.inset + conn.slotDepth/2, y, 0); }
        cutters.push(slot);
      }

      if (conn.mode === "pegs" || conn.mode === "both"){
        const pegDepth = conn.slotDepth * 0.7;
        const peg = new THREE.BoxGeometry(prof.pegW, prof.pegH, pegDepth);
        if (e === "n") peg.translate(0, y, -d/2 - pegDepth/2 + 0.01);
        if (e === "s") peg.translate(0, y,  d/2 + pegDepth/2 - 0.01);
        if (e === "e"){ peg.rotateY(Math.PI/2); peg.translate( w/2 + pegDepth/2 - 0.01, y, 0); }
        if (e === "w"){ peg.rotateY(Math.PI/2); peg.translate(-w/2 - pegDepth/2 + 0.01, y, 0); }
        additions.push(peg);
      }
    }
  }

  let geo = slab;
  if (additions.length) geo = safeMerge([geo, ...additions]);
  if (cutters.length) geo = csgSubtract(geo, cutters);
  return geo;
}

/* ==========================
   Feet connectors (FIXED for corner)
   Accepts points: [{x,z}, ...]
========================== */
function applyFootConnectorsXZ(baseGeo, footPoints, footW, footH, conn){
  if (conn.mode === "none") return baseGeo;

  const prof = connectorProfile(conn.sizeMode, conn.tol);
  const cutters = [];
  const adds = [];

  const y = footH*0.5;
  const zOut = (footW/2);

  for (const p of footPoints){
    const fx = p.x;
    const fz = p.z;

    if ((conn.mode === "slots" || conn.mode === "both") && CSG_OK){
      const slot = new THREE.BoxGeometry(prof.slotW, Math.min(prof.slotH, footH*0.9), conn.slotDepth);
      slot.translate(fx, y, fz + zOut - conn.inset - conn.slotDepth/2);
      cutters.push(slot);
    }

    if (conn.mode === "pegs" || conn.mode === "both"){
      const pegDepth = conn.slotDepth * 0.7;
      const peg = new THREE.BoxGeometry(prof.pegW, Math.min(prof.pegH, footH*0.9), pegDepth);
      peg.translate(fx, y, fz + zOut + pegDepth/2 - 0.01);
      adds.push(peg);
    }
  }

  let g = baseGeo;
  if (adds.length) g = safeMerge([g, ...adds]);
  if (cutters.length) g = csgSubtract(g, cutters);
  return g;
}

/* ==========================
   Walls
========================== */
function buildWallStraight({len, thick, height, feet, conn, apply}){
  const wall = new THREE.BoxGeometry(len, height, thick);
  wall.translate(0, feet.footH + height/2, 0);

  const footL = feet.footL;
  const footH = feet.footH;
  const footW = thick + 4;

  const xL = -len*0.25;
  const xR =  len*0.25;

  const footLeft = new THREE.BoxGeometry(footL, footH, footW);
  footLeft.translate(xL, footH/2, 0);

  const footRight = new THREE.BoxGeometry(footL, footH, footW);
  footRight.translate(xR, footH/2, 0);

  let baseGeo = safeMerge([wall, footLeft, footRight]);

  if (apply){
    const feetList = wallFootList(conn.wallFeet);
    const pts = [];
    if (feetList.includes("left"))  pts.push({x:xL, z:0});
    if (feetList.includes("right")) pts.push({x:xR, z:0});
    baseGeo = applyFootConnectorsXZ(baseGeo, pts, footW, footH, conn);
  }
  return baseGeo;
}

function buildWallCorner({len, thick, height, feet, conn, apply}){
  const a = new THREE.BoxGeometry(len, height, thick);
  a.translate(0, feet.footH + height/2, (len/2 - thick/2));
  const b = new THREE.BoxGeometry(thick, height, len);
  b.translate((len/2 - thick/2), feet.footH + height/2, 0);

  const footL = feet.footL, footH = feet.footH, footW = thick + 4;

  // Feet: two on the "a" leg, one on the "b" leg
  const x1 = -len*0.25, x2 = 0;
  const zA = (len/2 - thick/2);        // leg A feet sit here
  const xB = (len/2 - thick/2), zB = -len*0.25; // leg B foot sits here

  const f1 = new THREE.BoxGeometry(footL, footH, footW);
  f1.translate(x1, footH/2, zA);

  const f2 = new THREE.BoxGeometry(footL, footH, footW);
  f2.translate(x2, footH/2, zA);

  const f3 = new THREE.BoxGeometry(footL, footH, footW);
  f3.translate(xB, footH/2, zB);

  let baseGeo = safeMerge([a,b,f1,f2,f3]);

  if (apply){
    const feetList = wallFootList(conn.wallFeet);
    const pts = [];
    // map left/right to the two "a" leg feet, and include the corner foot when "both"
    if (feetList.includes("left"))  pts.push({x:x1, z:zA});
    if (feetList.includes("right")) pts.push({x:x2, z:zA});
    if (conn.wallFeet === "both")   pts.push({x:xB, z:zB});
    baseGeo = applyFootConnectorsXZ(baseGeo, pts, footW, footH, conn);
  }
  return baseGeo;
}

function buildDoorway({len, thick, height, feet, grid, conn, apply}){
  const doorW = Math.max(18, grid*0.9);
  const doorH = Math.max(24, height*0.75);

  const sideW = (len - doorW)/2;

  const left = new THREE.BoxGeometry(sideW, height, thick);
  left.translate(-len/2 + sideW/2, feet.footH + height/2, 0);

  const right = new THREE.BoxGeometry(sideW, height, thick);
  right.translate(len/2 - sideW/2, feet.footH + height/2, 0);

  const topH = Math.max(4, height - doorH);
  const top = new THREE.BoxGeometry(doorW, topH, thick);
  top.translate(0, feet.footH + doorH + topH/2, 0);

  const footL = feet.footL, footH = feet.footH, footW = thick + 4;
  const fxL = -len/2 + sideW*0.55;
  const fxR =  len/2 - sideW*0.55;

  const fL = new THREE.BoxGeometry(footL, footH, footW);
  fL.translate(fxL, footH/2, 0);

  const fR = new THREE.BoxGeometry(footL, footH, footW);
  fR.translate(fxR, footH/2, 0);

  let baseGeo = safeMerge([left,right,top,fL,fR]);

  if (apply){
    const feetList = wallFootList(conn.wallFeet);
    const pts = [];
    if (feetList.includes("left"))  pts.push({x:fxL, z:0});
    if (feetList.includes("right")) pts.push({x:fxR, z:0});
    baseGeo = applyFootConnectorsXZ(baseGeo, pts, footW, footH, conn);
  }

  return baseGeo;
}

/* ==========================
   View helpers
========================== */
function setMesh(geometry){
  if (currentMesh){
    scene.remove(currentMesh);
    currentMesh.geometry.dispose();
  }
  geometry.computeVertexNormals();
  currentMesh = new THREE.Mesh(geometry, material);
  scene.add(currentMesh);

  const box = new THREE.Box3().setFromObject(currentMesh);
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  currentMesh.position.sub(center);
  currentMesh.position.y += size.y/2;

  const maxDim = Math.max(size.x, size.y, size.z);
  camera.position.set(maxDim*1.3, maxDim*1.0, maxDim*1.3);
  controls.target.set(0, size.y*0.45, 0);
  controls.update();
}

function resize(){
  const r = view.getBoundingClientRect();
  renderer.setSize(r.width, r.height);
  camera.aspect = r.width / r.height;
  camera.updateProjectionMatrix();
}
window.addEventListener("resize", resize);

/* ==========================
   Presets + generate
========================== */
function applyPreset(){
  const p = document.getElementById("preset").value;
  const set = (id,val)=>document.getElementById(id).value = String(val);

  if (p === "tile_1"){
    document.getElementById("model").value = "tile";
    set("w", GRID); set("d", GRID); set("tileT", 3);
    document.getElementById("connMode").value = "slots";
    document.getElementById("applyTo").value = "tile";
  } else if (p === "tile_2"){
    document.getElementById("model").value = "tile";
    set("w", GRID*2); set("d", GRID*2); set("tileT", 3);
    document.getElementById("connMode").value = "slots";
    document.getElementById("applyTo").value = "tile";
  } else if (p === "wall_2"){
    document.getElementById("model").value = "wall_straight";
    set("w", GRID*2); set("d", GRID*2); set("h", 35); set("wallT", 8);
    document.getElementById("connMode").value = "slots";
    document.getElementById("applyTo").value = "wall";
  } else if (p === "wall_corner"){
    document.getElementById("model").value = "wall_corner";
    set("w", GRID*2); set("d", GRID*2); set("h", 35); set("wallT", 8);
    document.getElementById("connMode").value = "slots";
    document.getElementById("applyTo").value = "wall";
  } else if (p === "doorway"){
    document.getElementById("model").value = "doorway";
    set("w", GRID*2); set("d", GRID*2); set("h", 35); set("wallT", 8);
    document.getElementById("connMode").value = "slots";
    document.getElementById("applyTo").value = "wall";
  }
}

function regenerateGrid(){
  scene.remove(gridHelper);
  gridHelper.geometry.dispose();
  gridHelper = new THREE.GridHelper(500, Math.floor(500 / GRID), 0x2a3558, 0x222a40);
  gridHelper.position.y = -0.01;
  scene.add(gridHelper);
}

function generate(){
  const snap = document.getElementById("snap").value === "on";
  const model = document.getElementById("model").value;

  let w = Math.max(1, Number(document.getElementById("w").value));
  let d = Math.max(1, Number(document.getElementById("d").value));
  let h = Math.max(1, Number(document.getElementById("h").value));

  if (snap){
    w = snapVal(w, GRID);
    d = snapVal(d, GRID);
  }

  regenerateGrid();

  const tileT = clamp(Number(document.getElementById("tileT").value), 2, 12);
  const wallT = clamp(Number(document.getElementById("wallT").value), 4, 20);

  const applyTo = document.getElementById("applyTo").value;
  const conn = {
    mode: document.getElementById("connMode").value,
    tol: clamp(Number(document.getElementById("tol").value), 0, 1.0),
    sizeMode: document.getElementById("connSize").value,
    inset: clamp(Number(document.getElementById("inset").value), 0, 10),
    slotDepth: clamp(Number(document.getElementById("slotDepth").value), 2, 20),
    tileEdges: document.getElementById("tileEdges").value,
    wallFeet: document.getElementById("wallFeet").value
  };

  // If user requests slots but CSG isn't available, show a clear message
  if ((conn.mode === "slots" || conn.mode === "both") && !CSG_OK){
    log("⚠️ CSG not available. Slot cutting disabled (pegs still work).");
  }

  const feet = {
    footL: clamp(Number(document.getElementById("footL").value), 6, 30),
    footH: clamp(Number(document.getElementById("footH").value), 2, 12)
  };

  let geo;

  if (model === "tile"){
    const emboss = document.getElementById("emboss").value;
    geo = buildTile({
      w, d, thickness: tileT, emboss, grid: GRID,
      conn: (applyTo === "tile" || applyTo === "both") ? conn : { mode:"none" }
    });
  } else if (model === "wall_straight"){
    geo = buildWallStraight({
      len: w, thick: wallT, height: Math.max(10, h), feet, conn,
      apply: (applyTo === "wall" || applyTo === "both") && conn.mode !== "none"
    });
  } else if (model === "wall_corner"){
    geo = buildWallCorner({
      len: w, thick: wallT, height: Math.max(10, h), feet, conn,
      apply: (applyTo === "wall" || applyTo === "both") && conn.mode !== "none"
    });
  } else if (model === "doorway"){
    geo = buildDoorway({
      len: w, thick: wallT, height: Math.max(10, h), feet, grid: GRID, conn,
      apply: (applyTo === "wall" || applyTo === "both") && conn.mode !== "none"
    });
  } else {
    geo = new THREE.BoxGeometry(20,20,20);
  }

  setMesh(geo);
}

/* ==========================
   Export
========================== */
function exportSTL(){
  if (!currentMesh) return alert("Generate a model first.");

  const model = document.getElementById("model").value;
  const w = document.getElementById("w").value;
  const d = document.getElementById("d").value;
  const h = document.getElementById("h").value;
  const tol = document.getElementById("tol").value;
  const mode = document.getElementById("connMode").value;

  const exporter = new STLExporter();
  const stlString = exporter.parse(currentMesh, { binary:false });
  const blob = new Blob([stlString], { type:"model/stl" });

  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `Dungeon25_${model}_${w}x${d}x${h}_tol${tol}_${mode}.stl`;
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ==========================
   Auto-save settings (QoL)
========================== */
const SAVE_KEYS = ["preset","model","snap","w","d","h","wallT","applyTo","connMode","tol","connSize","tileEdges","wallFeet","inset","slotDepth","footL","footH","tileT","emboss"];
function saveSettings(){
  const data = {};
  for (const k of SAVE_KEYS){
    const el = document.getElementById(k);
    if (el) data[k] = el.value;
  }
  localStorage.setItem("dnd_terrain_settings", JSON.stringify(data));
}
function loadSettings(){
  try{
    const data = JSON.parse(localStorage.getItem("dnd_terrain_settings") || "{}");
    for (const k of SAVE_KEYS){
      const el = document.getElementById(k);
      if (el && data[k] != null) el.value = data[k];
    }
  }catch{}
}
for (const k of SAVE_KEYS){
  const el = document.getElementById(k);
  if (el) el.addEventListener("change", saveSettings);
}
loadSettings();

/* ==========================
   Wire up buttons (busy lock)
========================== */
async function runGenerateSafely(){
  if (BUSY) return;
  setBusy(true, "⏳ Generating…");
  try{
    generate();
    log(CSG_OK ? "READY ✅ Generated" : "READY ✅ Generated (peg-only if slots requested)");
  }catch(e){
    console.error(e);
    log("❌ ERROR:\n" + (e.stack || e.message || e));
  }finally{
    setBusy(false);
  }
}

document.getElementById("preset").addEventListener("change", () => { applyPreset(); runGenerateSafely(); });
document.getElementById("gen").addEventListener("click", runGenerateSafely);
document.getElementById("export").addEventListener("click", () => {
  try{ exportSTL(); }
  catch(e){ console.error(e); log("❌ EXPORT ERROR:\n"+(e.stack||e.message||e)); }
});

function init(){
  resize();
  applyPreset();
  runGenerateSafely();
}
init();

(function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();
</script>
